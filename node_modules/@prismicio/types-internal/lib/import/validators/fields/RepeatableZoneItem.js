"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RepeatableZoneItem = void 0;
const tslib_1 = require("tslib");
const E = (0, tslib_1.__importStar)(require("fp-ts/Either"));
const function_1 = require("fp-ts/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const common_1 = require("../../../common");
const function_2 = require("../../../validators/function");
const nestable_1 = require("./nestable");
/**
 * A custom type for an item of a repeatable zone. This type of structure can be found in the 'primary' and 'items' fields of a slice or in the group field.
 *
 * @param fieldModels a record of all nestable widgets that can be used in the zone
 */
const RepeatableZoneItem = (fieldModels) => new t.Type("RepeatableZoneItem", (u) => t.record(common_1.WidgetKey, t.unknown).is(u) &&
    Object.values(u).reduce((acc, value) => acc && nestable_1.ImportNestable.is(value), true), (u, c) => {
    const codecEntries = Object.entries(fieldModels).map(([key, model]) => [key, nestable_1.ImportNestable.getCodec(model)]);
    const groupCodec = (0, function_2.withCustomError)(t.partial({
        ...Object.fromEntries(codecEntries),
    }), () => "The value must be an object");
    return (0, function_1.pipe)(groupCodec.validate(u, c), E.chain((decodedContent) => {
        // Validate if all fields are present in the model
        const keys = Object.keys(decodedContent);
        const errors = keys.flatMap((key) => fieldModels[key]
            ? []
            : [
                {
                    value: decodedContent[key],
                    context: c,
                    message: `The field '${key}' is not defined in the custom type`,
                },
            ]);
        return errors.length > 0
            ? t.failures(errors)
            : t.success(decodedContent); // We can never have a key with decoded value 'undefined' so we can ignore the type derived from t.partial
    }));
}, t.identity);
exports.RepeatableZoneItem = RepeatableZoneItem;
