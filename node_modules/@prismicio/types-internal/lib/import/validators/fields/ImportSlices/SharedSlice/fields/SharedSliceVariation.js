"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedSliceVariation = void 0;
const tslib_1 = require("tslib");
const E = (0, tslib_1.__importStar)(require("fp-ts/Either"));
const function_1 = require("fp-ts/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const customtypes_1 = require("../../../../../../customtypes");
const validators_1 = require("../../../../../../validators");
const utils_1 = require("../utils");
/**
 * variation - the validated variation of the slice
 * data - Variation data matching the variation. We return it alongside the validated variation, because it is needed to decode the 'primary' and 'items' fields in the SharedSlice.
 */
const SharedSliceVariationShape = t.strict({
    variation: validators_1.NonEmptyString,
    data: customtypes_1.Variation,
});
/**
 * Builds the decoder for the 'variation' field in the SharedSlice. Alongside the decoded 'variation' it also returns the Variation data matching the variation custom type.
 * @param slice SharedSlice from the custom type
 */
const SharedSliceVariation = (slice) => new t.Type("variation", (u) => SharedSliceVariationShape.is(u), (u, c) => (0, function_1.pipe)(validators_1.NonEmptyString.validate(u, c), E.chain((variation) => (0, function_1.pipe)((0, utils_1.findSliceVariation)(slice)(variation), E.fold((err) => t.failure(u, c, err), (data) => t.success({ variation, data }))))), ({ variation }) => variation);
exports.SharedSliceVariation = SharedSliceVariation;
