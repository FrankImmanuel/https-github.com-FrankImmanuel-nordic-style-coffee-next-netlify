"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedSlice = void 0;
const tslib_1 = require("tslib");
const E = (0, tslib_1.__importStar)(require("fp-ts/Either"));
const function_1 = require("fp-ts/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const validators_1 = require("../../../../../validators");
const RepeatableZone_1 = require("../../RepeatableZone");
const RepeatableZoneItem_1 = require("../../RepeatableZoneItem");
const fields_1 = require("./fields");
const SharedSliceShape = t.strict({
    id: fields_1.OptionalSharedSliceId,
    slice_type: validators_1.NonEmptyString,
    name: validators_1.String,
    variation: validators_1.NonEmptyString,
    primary: t.union([t.undefined, t.null, t.record(validators_1.NonEmptyString, t.unknown)]),
    items: t.union([
        t.undefined,
        t.null,
        t.array(t.record(validators_1.NonEmptyString, t.unknown)),
    ]),
    slice_label: t.union([t.undefined, t.null, validators_1.String]),
    version: t.union([t.undefined, t.null, validators_1.String]),
});
const SharedSlice = (sharedSlices) => new t.Type("SharedSlice", (u) => SharedSliceShape.is(u), (u, c) => (0, function_1.pipe)(
// We validate the base fields that we can validate directly based on the provided 'sharedSlices'
t
    .type({
    id: fields_1.OptionalSharedSliceId,
    slice_type: (0, fields_1.SharedSliceType)(sharedSlices),
    slice_label: t.union([t.undefined, t.null, validators_1.String]),
    version: t.union([t.undefined, t.null, validators_1.String]),
})
    .validate(u, c), E.chain((decoded) => (0, function_1.pipe)(
// We validate the 'variation' field, for which we need the SharedSlice custom type retrieved in the first step
t
    .type({
    variation: (0, fields_1.SharedSliceVariation)(decoded.slice_type.data),
})
    .validate(u, c), E.map(({ variation }) => ({ ...decoded, variation })))), E.chain((decoded) => {
    var _a, _b;
    return (0, function_1.pipe)(
    // We validate the 'primary' and 'items' content fields, for which we need the Variation custom type retrieved in the previous step
    t
        .partial({
        primary: (0, RepeatableZoneItem_1.RepeatableZoneItem)((_a = decoded.variation.data.primary) !== null && _a !== void 0 ? _a : {}),
        items: (0, RepeatableZone_1.RepeatableZone)((_b = decoded.variation.data.items) !== null && _b !== void 0 ? _b : {}),
    })
        .validate(u, c), E.map(({ primary, items }) => ({ ...decoded, primary, items })));
}), E.map(({ id, slice_type, variation, primary, items, slice_label, version, }) => ({
    id,
    slice_type: slice_type.slice_type,
    name: slice_type.data.name,
    variation: variation.variation,
    primary,
    items,
    slice_label,
    version: version !== null && version !== void 0 ? version : variation.data.version,
}))), t.identity);
exports.SharedSlice = SharedSlice;
