"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedSliceType = void 0;
const tslib_1 = require("tslib");
const E = (0, tslib_1.__importStar)(require("fp-ts/Either"));
const function_1 = require("fp-ts/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const customtypes_1 = require("../../../../../../customtypes");
const validators_1 = require("../../../../../../validators");
const utils_1 = require("../utils");
/**
 * slice_type - the validated slice_type
 * slice - SharedSlice custom type data matching the slice_type. We return it alongside the validated slice_type, because it is needed to decode the 'variation' field in the SharedSlice (see SharedSliceVariation.ts)
 */
const SharedSliceTypeShape = t.strict({
    slice_type: validators_1.NonEmptyString,
    slice: customtypes_1.SharedSlice,
});
/**
 * Builds the decoder for the 'slice_type' field in the SharedSlice. Alongside the decoded 'slice_type' it also returns the SharedSlice data matching the slice_type.
 * @param slices all the SharedSlices from the custom type
 */
const SharedSliceType = (slices) => new t.Type("slice_type", (u) => SharedSliceTypeShape.is(u), (u, c) => (0, function_1.pipe)(validators_1.NonEmptyString.validate(u, c), E.chain((slice_type) => (0, function_1.pipe)((0, utils_1.findSlice)(slices)(slice_type), E.fold((err) => t.failure(u, c, err), (data) => t.success({ slice_type, data }))))), ({ slice_type }) => slice_type);
exports.SharedSliceType = SharedSliceType;
