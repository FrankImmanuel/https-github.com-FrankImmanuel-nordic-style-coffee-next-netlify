"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportSlices = void 0;
const tslib_1 = require("tslib");
const E = (0, tslib_1.__importStar)(require("fp-ts/Either"));
const function_1 = require("fp-ts/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const validators_1 = require("../../../../validators");
const ImportContent_1 = require("../ImportContent");
const SharedSlice_1 = require("./SharedSlice");
const utils_1 = require("./utils");
const ImportSlices = (staticSlices) => {
    const supportedSlices = (0, utils_1.extractSupportedSlices)(staticSlices);
    // For now we only support the SharedSlice, however if we want to support more in the future
    // we would have to change the codec here to something like this: t.array(t.union([ImportSharedSlice(sharedSlices), NewSliceCodec(newSliceCustomTypes)])).
    const SharedSliceCodec = (0, SharedSlice_1.SharedSlice)(supportedSlices);
    const SlicesArrayCodec = t.array(SharedSliceCodec);
    return (0, ImportContent_1.ImportContent)("Slices", (0, validators_1.EmptyArrayOrElse)(new t.ArrayType(SlicesArrayCodec.name, (u) => SlicesArrayCodec.is(u), (u, c) => {
        return (0, function_1.pipe)(SlicesArrayCodec.validate(u, c), E.chain((slices) => {
            // This part might not make sense for all Slice types in the future, but for now we only support the SharedSlice
            // In case we support more in the future, we would have to filter only the relevant type for this check
            const sharedSliceDuplicates = (0, utils_1.findImportSharedSliceDuplicateIds)(slices);
            if (sharedSliceDuplicates.length > 0) {
                return t.failure(slices, [], `Duplicate slice IDs detected: ${sharedSliceDuplicates.join(", ")}`);
            }
            return t.success(slices);
        }));
    }, t.identity, SharedSliceCodec)));
};
exports.ImportSlices = ImportSlices;
