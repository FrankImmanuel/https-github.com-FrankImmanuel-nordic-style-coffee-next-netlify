"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportDocument = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const customtypes_1 = require("../../customtypes");
const Objects_1 = require("../../utils/Objects");
const function_2 = require("../../validators/function");
const ImportField_1 = require("./fields/ImportField");
const rawImportDocument = (0, function_2.withCustomError)(t.UnknownRecord, () => "document is not an object");
function validateField(document, customType) {
    return (key, content, model) => {
        // the field is not defined in the custom type -> extra field or typo
        if (!model) {
            const error = {
                value: content,
                context: [{ key: key, type: t.unknown }],
                message: `The field ${key} is not part of the Custom type`,
            };
            return fp_ts_1.either.left([error]);
        }
        // retrieving the right codec then testing out fieldValue with it.
        const { result, codec } = ImportField_1.ImportField.decode(model)(content);
        // error.context is pointing at root when it should point to a `fieldKey`.
        // We need to override the context to make it right.
        if ((0, Either_1.isLeft)(result)) {
            const errors = result.left.map((error) => {
                const contextHead = error.context[0];
                const context = [
                    { key: "", actual: document, type: (0, exports.ImportDocument)(customType) },
                    contextHead
                        ? { ...contextHead, key: key }
                        : { key: key, actual: content, type: codec },
                    ...error.context.slice(1),
                ];
                return { ...error, context };
            });
            return fp_ts_1.either.left(errors);
        }
        return fp_ts_1.either.right(result.right);
    };
}
function validateDocument(customType, rawDoc) {
    const fieldModels = (0, customtypes_1.flattenCustomTypeFields)(customType);
    const { document, errors } = Object.entries(rawDoc).reduce((acc, [fieldKey, fieldValue]) => {
        const parsedField = validateField(rawDoc, customType)(fieldKey, fieldValue, fieldModels[fieldKey]);
        if ((0, Either_1.isLeft)(parsedField))
            return { ...acc, errors: [...acc.errors, ...parsedField.left] };
        return {
            ...acc,
            document: { ...acc.document, [fieldKey]: parsedField.right },
        };
    }, { document: {}, errors: [] });
    if (errors.length > 0)
        return fp_ts_1.either.left(errors);
    return fp_ts_1.either.right(document);
}
const ImportDocument = (customType) => new t.Type("ImportDocument", (u) => (0, Objects_1.isObject)(u), (raw) => {
    return (0, function_1.pipe)(rawImportDocument.decode(raw), fp_ts_1.either.chain((doc) => validateDocument(customType, doc)));
}, t.identity);
exports.ImportDocument = ImportDocument;
